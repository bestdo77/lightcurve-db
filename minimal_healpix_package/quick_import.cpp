#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <chrono>
#include <filesystem>
#include <map>
#include <algorithm>
#include <memory>
#include <iomanip>
#include <cstring>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <atomic>
#include <future>

// TDengine Â§¥Êñá‰ª∂
#include <taos.h>

// HealPix C++ Â∫ìÂ§¥Êñá‰ª∂
#include <healpix_cxx/healpix_base.h>
#include <healpix_cxx/pointing.h>

const double PI = 3.14159265358979323846;

// Â∫¶Êï∞ËΩ¨ÂºßÂ∫¶ÂáΩÊï∞
inline double deg2rad(double deg) {
    return deg * PI / 180.0;
}

struct AstronomicalRecord {
    std::string timestamp;
    int source_id;
    double ra;
    double dec;
    double mag;
    double jd_tcb;
    long healpix_id;
};

// ËøõÂ∫¶Êù°ÊòæÁ§∫Á±ª
class ProgressBar {
private:
    std::mutex print_mutex_;
    int bar_width_;
    
public:
    ProgressBar(int width = 50) : bar_width_(width) {}
    
    void displayProgress(int current, int total, int success, int error, double rate, 
                        int elapsed_seconds) {
        std::lock_guard<std::mutex> lock(print_mutex_);
        
        // ËÆ°ÁÆóËøõÂ∫¶ÁôæÂàÜÊØî
        double progress = (total > 0) ? static_cast<double>(current) / total : 0.0;
        int filled_width = static_cast<int>(progress * bar_width_);
        
        // Ê∏ÖÈô§ÂΩìÂâçË°åÂπ∂ÁßªÂà∞Ë°åÈ¶ñ
        std::cout << "\r\033[K";
        
        // ÊòæÁ§∫ËøõÂ∫¶Êù°
        std::cout << "üöÄ ËøõÂ∫¶: [";
        for (int i = 0; i < bar_width_; ++i) {
            if (i < filled_width) {
                std::cout << "‚ñà";
            } else {
                std::cout << "‚ñë";
            }
        }
        std::cout << "] ";
        
        // ÊòæÁ§∫ÁôæÂàÜÊØîÂíåÁªüËÆ°‰ø°ÊÅØ
        std::cout << std::fixed << std::setprecision(1) << (progress * 100.0) << "% ";
        std::cout << "(" << current << "/" << total << ") ";
        std::cout << "‚úÖ" << success << " ‚ùå" << error << " ";
        std::cout << "‚ö°" << static_cast<int>(rate) << "Ë°å/Áßí ";
        
        // ÊòæÁ§∫Â∑≤Áî®Êó∂Èó¥
        int minutes = elapsed_seconds / 60;
        int seconds = elapsed_seconds % 60;
        std::cout << "‚è±Ô∏è" << minutes << ":" << std::setfill('0') << std::setw(2) << seconds;
        
        std::cout << std::flush;
        
        // Â¶ÇÊûúÂÆåÊàêÔºåÊç¢Ë°å
        if (current >= total) {
            std::cout << std::endl;
        }
    }
    
    void displayMessage(const std::string& message) {
        std::lock_guard<std::mutex> lock(print_mutex_);
        std::cout << "\r\033[K" << message << std::endl << std::flush;
    }
};

// Á∫øÁ®ãÂÆâÂÖ®ÁöÑÁªüËÆ°Á±ª
class ThreadSafeStats {
private:
    std::mutex mutex_;
    std::atomic<int> total_success_{0};
    std::atomic<int> total_error_{0};
    std::atomic<int> processed_groups_{0};

public:
    void addSuccess(int count) { total_success_ += count; }
    void addError(int count) { total_error_ += count; }
    void incrementGroup() { processed_groups_++; }
    
    int getSuccess() const { return total_success_; }
    int getError() const { return total_error_; }
    int getProcessedGroups() const { return processed_groups_; }
};

// TDengine ËøûÊé•Ê±†
class TDengineConnectionPool {
private:
    std::queue<TAOS*> connections_;
    std::mutex mutex_;
    std::condition_variable cv_;
    std::string host_, user_, password_, db_name_;
    int port_;
    int pool_size_;

public:
    TDengineConnectionPool(const std::string& host, const std::string& user, 
                          const std::string& password, const std::string& db_name,
                          int port, int pool_size = 8) 
        : host_(host), user_(user), password_(password), db_name_(db_name), 
          port_(port), pool_size_(pool_size) {
        
        // ÂàùÂßãÂåñËøûÊé•Ê±†
        for (int i = 0; i < pool_size_; ++i) {
            TAOS* conn = taos_connect(host_.c_str(), user_.c_str(), password_.c_str(), nullptr, port_);
            if (conn) {
                // ‰ΩøÁî®Êï∞ÊçÆÂ∫ì
                std::string use_db_sql = "USE " + db_name_;
                TAOS_RES* result = taos_query(conn, use_db_sql.c_str());
                if (taos_errno(result) == 0) {
                    connections_.push(conn);
                } else {
                    taos_close(conn);
                }
                taos_free_result(result);
            }
        }
        
        std::cout << "‚úÖ ËøûÊé•Ê±†ÂàùÂßãÂåñÂÆåÊàêÔºåËøûÊé•Êï∞: " << connections_.size() << std::endl;
    }

    ~TDengineConnectionPool() {
        while (!connections_.empty()) {
            taos_close(connections_.front());
            connections_.pop();
        }
    }

    TAOS* getConnection() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !connections_.empty(); });
        
        TAOS* conn = connections_.front();
        connections_.pop();
        return conn;
    }

    void returnConnection(TAOS* conn) {
        std::lock_guard<std::mutex> lock(mutex_);
        connections_.push(conn);
        cv_.notify_one();
    }

    size_t size() const {
        std::lock_guard<std::mutex> lock(const_cast<std::mutex&>(mutex_));
        return connections_.size();
    }
};

// Â∑•‰Ωú‰ªªÂä°ÁªìÊûÑ
struct ImportTask {
    long healpix_id;
    int source_id;
    std::vector<const AstronomicalRecord*> records;
    
    ImportTask(long hid, int sid, const std::vector<const AstronomicalRecord*>& recs)
        : healpix_id(hid), source_id(sid), records(recs) {}
};

class TDengineHealpixImporter {
private:
    TAOS* conn;
    std::string db_name;
    std::string table_name;
    int nside_base;
    int nside_fine;
    int count_threshold;
    int batch_size;
    int thread_count;
    std::unique_ptr<Healpix_Base> healpix_base;
    std::unique_ptr<Healpix_Base> healpix_fine;
    std::unique_ptr<TDengineConnectionPool> conn_pool;

public:
    TDengineHealpixImporter(const std::string& database,
                           const std::string& host = "localhost",
                           const std::string& user = "root",
                           const std::string& password = "taosdata",
                           int port = 6030,
                           int nside_base_param = 64,
                           int nside_fine_param = 256,
                           int count_threshold_param = 10000,
                           int batch_size_param = 500,
                           int thread_count_param = 8)
        : conn(nullptr), db_name(database), table_name("sensor_data"),
          nside_base(nside_base_param), nside_fine(nside_fine_param),
          count_threshold(count_threshold_param), batch_size(batch_size_param),
          thread_count(thread_count_param) {
        
        // ÂàùÂßãÂåñ HealPix
        healpix_base = std::make_unique<Healpix_Base>(nside_base, NEST, SET_NSIDE);
        healpix_fine = std::make_unique<Healpix_Base>(nside_fine, NEST, SET_NSIDE);
        std::cout << "‚úÖ HealPix ÂàùÂßãÂåñÊàêÂäüÔºåÂü∫Á°ÄNSIDE=" << nside_base 
                 << "ÔºåÁªÜÂàÜNSIDE=" << nside_fine << std::endl;
        
        // ÂàùÂßãÂåñ TDengine
        taos_init();
        
        // ËøûÊé•Êï∞ÊçÆÂ∫ì
        conn = taos_connect(host.c_str(), user.c_str(), password.c_str(), nullptr, port);
        if (conn == nullptr) {
            throw std::runtime_error("Êó†Ê≥ïËøûÊé•Âà∞ TDengine: " + std::string(taos_errstr(conn)));
        }
        std::cout << "‚úÖ TDengine ËøûÊé•ÊàêÂäü" << std::endl;
        
        // ÂàùÂßãÂåñËøûÊé•Ê±†
        conn_pool = std::make_unique<TDengineConnectionPool>(host, user, password, database, port, thread_count);
    }
    
    ~TDengineHealpixImporter() {
        if (conn) {
            taos_close(conn);
        }
        taos_cleanup();
    }
    
    bool dropDatabase() {
        std::cout << "‚ö†Ô∏è Ê≠£Âú®Âà†Èô§Êï∞ÊçÆÂ∫ì: " << db_name << std::endl;
        
        std::string sql = "DROP DATABASE IF EXISTS " + db_name;
        TAOS_RES* result = taos_query(conn, sql.c_str());
        
        if (taos_errno(result) != 0) {
            std::cerr << "‚ùå Âà†Èô§Êï∞ÊçÆÂ∫ìÂ§±Ë¥•: " << taos_errstr(result) << std::endl;
            taos_free_result(result);
            return false;
        }
        
        taos_free_result(result);
        std::cout << "‚úÖ Êï∞ÊçÆÂ∫ì " << db_name << " Â∑≤Âà†Èô§" << std::endl;
        return true;
    }
    
    bool createSuperTable() {
        std::cout << "üèóÔ∏è ÂàõÂª∫Êï∞ÊçÆÂ∫ìÂíåË∂ÖÁ∫ßË°®..." << std::endl;
        
        // ÂàõÂª∫Êï∞ÊçÆÂ∫ì
        std::string create_db_sql = "CREATE DATABASE IF NOT EXISTS " + db_name;
        TAOS_RES* result = taos_query(conn, create_db_sql.c_str());
        if (taos_errno(result) != 0) {
            std::cerr << "‚ùå ÂàõÂª∫Êï∞ÊçÆÂ∫ìÂ§±Ë¥•: " << taos_errstr(result) << std::endl;
            taos_free_result(result);
            return false;
        }
        taos_free_result(result);
        
        // ‰ΩøÁî®Êï∞ÊçÆÂ∫ì
        std::string use_db_sql = "USE " + db_name;
        result = taos_query(conn, use_db_sql.c_str());
        if (taos_errno(result) != 0) {
            std::cerr << "‚ùå ‰ΩøÁî®Êï∞ÊçÆÂ∫ìÂ§±Ë¥•: " << taos_errstr(result) << std::endl;
            taos_free_result(result);
            return false;
        }
        taos_free_result(result);
        
        // ÂàõÂª∫Ë∂ÖÁ∫ßË°®
        std::string create_table_sql = 
            "CREATE STABLE IF NOT EXISTS " + table_name + " ("
            "ts TIMESTAMP, "
            "ra DOUBLE, "
            "dec DOUBLE, "
            "mag DOUBLE, "
            "jd_tcb DOUBLE"
            ") TAGS (healpix_id BIGINT, source_id BIGINT)";
        
        result = taos_query(conn, create_table_sql.c_str());
        if (taos_errno(result) != 0) {
            std::cerr << "‚ùå ÂàõÂª∫Ë∂ÖÁ∫ßË°®Â§±Ë¥•: " << taos_errstr(result) << std::endl;
            taos_free_result(result);
            return false;
        }
        taos_free_result(result);
        
        std::cout << "‚úÖ Ë∂ÖÁ∫ßË°® " << table_name << " Â∑≤ÂàõÂª∫" << std::endl;
        return true;
    }
    
    // ÁÆÄÂåñÁöÑËá™ÈÄÇÂ∫îHealPix IDËÆ°ÁÆó
    long calculateAdaptiveHealpixId(double ra, double dec, int source_id, 
                                   const std::map<long, int>& base_counts) {
        // È™åËØÅÂíåË£ÅÂâ™ÂùêÊ†áÂÄºÂà∞ÊúâÊïàËåÉÂõ¥
        ra = fmod(ra, 360.0);
        if (ra < 0) ra += 360.0;  // Á°Æ‰øù RA Âú® [0, 360) ËåÉÂõ¥ÂÜÖ
        
        dec = std::max(-90.0, std::min(90.0, dec));  // Ë£ÅÂâ™ DEC Âà∞ [-90, 90] ËåÉÂõ¥
        
        // ËÆ°ÁÆóÂü∫Á°ÄÂàÜËæ®ÁéáÁöÑ healpix ID
        pointing pt(deg2rad(90.0 - dec), deg2rad(ra));
        long base_id = healpix_base->ang2pix(pt);
        
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÁªÜÂàÜ
        auto it = base_counts.find(base_id);
        int count = (it != base_counts.end()) ? it->second : 0;
        
        if (count > count_threshold) {
            // ÈúÄË¶ÅÁªÜÂàÜÔºå‰ΩøÁî®ÁªÜÂàÜÂàÜËæ®Áéá
            long fine_id = healpix_fine->ang2pix(pt);
            return (base_id << 32) + fine_id;  // ÁªÑÂêàID
        } else {
            return base_id;
        }
    }
    
    std::vector<AstronomicalRecord> loadAndProcessData(const std::string& csv_file) {
        std::cout << "üìñ ËØªÂèñÂíåÂ§ÑÁêÜÊï∞ÊçÆÊñá‰ª∂: " << csv_file << std::endl;
        
        std::ifstream file(csv_file);
        if (!file.is_open()) {
            throw std::runtime_error("Êó†Ê≥ïÊâìÂºÄÊï∞ÊçÆÊñá‰ª∂: " + csv_file);
        }
        
        std::vector<AstronomicalRecord> records;
        std::string line;
        
        // Ë∑≥ËøáÂ§¥ÈÉ®
        std::getline(file, line);
        
        while (std::getline(file, line)) {
            std::stringstream ss(line);
            std::string item;
            std::vector<std::string> fields;
            
            while (std::getline(ss, item, ',')) {
                fields.push_back(item);
            }
            
            if (fields.size() >= 6) {
                AstronomicalRecord record;
                record.timestamp = fields[0];
                record.source_id = std::stoi(fields[1]);
                record.ra = std::stod(fields[2]);
                record.dec = std::stod(fields[3]);
                record.mag = std::stod(fields[4]);
                record.jd_tcb = std::stod(fields[5]);
                
                records.push_back(record);
            }
        }
        
        std::cout << "‚úÖ ÊàêÂäüËØªÂèñ " << records.size() << " Êù°ËÆ∞ÂΩï" << std::endl;
        
        // ÁªüËÆ°ÊØè‰∏™Âü∫Á°ÄhealpixÂå∫ÂùóÁöÑÂ§©‰ΩìÊï∞Èáè
        std::cout << "üîß ÂºÄÂßãËá™ÈÄÇÂ∫î healpix ÂàÜÂå∫ËÆ°ÁÆó..." << std::endl;
        std::map<long, int> base_counts;
        
        for (const auto& record : records) {
            // È™åËØÅÂíåË£ÅÂâ™ÂùêÊ†áÂÄº
            double clean_ra = fmod(record.ra, 360.0);
            if (clean_ra < 0) clean_ra += 360.0;
            double clean_dec = std::max(-90.0, std::min(90.0, record.dec));
            
            pointing pt(deg2rad(90.0 - clean_dec), deg2rad(clean_ra));
            long base_id = healpix_base->ang2pix(pt);
            base_counts[base_id]++;
        }
        
        std::cout << "üìä Âü∫Á°ÄÂàÜÂå∫ÁªüËÆ°:" << std::endl;
        std::cout << "   - ÊÄªÂå∫ÂùóÊï∞: " << base_counts.size() << std::endl;
        
        // ËÆ°ÁÆóÂπ≥ÂùáÂÄºÂíåÊúÄÂ§ßÂÄº
        long total_count = 0;
        int max_count = 0;
        for (const auto& pair : base_counts) {
            total_count += pair.second;
            max_count = std::max(max_count, pair.second);
        }
        double avg_count = static_cast<double>(total_count) / base_counts.size();
        std::cout << "   - Âπ≥ÂùáÂ§©‰Ωì/Âå∫Âùó: " << std::fixed << std::setprecision(1) << avg_count << std::endl;
        std::cout << "   - ÊúÄÂ§ßÂ§©‰Ωì/Âå∫Âùó: " << max_count << std::endl;
        
        // ÁªüËÆ°ÈúÄË¶ÅÁªÜÂàÜÁöÑÂå∫Âùó
        int large_blocks = 0;
        for (const auto& pair : base_counts) {
            if (pair.second > count_threshold) {
                large_blocks++;
            }
        }
        std::cout << "‚ö° ÈúÄË¶ÅÁªÜÂàÜÁöÑÂå∫Âùó: " << large_blocks << " ‰∏™" << std::endl;
        
        // ‰∏∫ÊØèÊù°ËÆ∞ÂΩïÂàÜÈÖçhealpix_id
        for (auto& record : records) {
            record.healpix_id = calculateAdaptiveHealpixId(record.ra, record.dec, record.source_id, base_counts);
        }
        
        // ÁîüÊàêÊò†Â∞ÑË°®
        std::map<int, long> source_healpix_map;
        for (const auto& record : records) {
            if (source_healpix_map.find(record.source_id) == source_healpix_map.end()) {
                source_healpix_map[record.source_id] = record.healpix_id;
            }
        }
        
        // ‰øùÂ≠òÊò†Â∞ÑË°®
        std::filesystem::create_directories("output/query_results");
        std::ofstream map_file("output/query_results/sourceid_healpix_map.csv");
        std::ofstream map_file_root("sourceid_healpix_map.csv");
        
        if (map_file.is_open() && map_file_root.is_open()) {
            map_file << "source_id,healpix_id\n";
            map_file_root << "source_id,healpix_id\n";
            
            for (const auto& pair : source_healpix_map) {
                map_file << pair.first << "," << pair.second << "\n";
                map_file_root << pair.first << "," << pair.second << "\n";
            }
            
            map_file.close();
            map_file_root.close();
            std::cout << "üíæ Â∑≤‰øùÂ≠òÊò†Â∞ÑË°®ÔºåÂÖ± " << source_healpix_map.size() << " Êù°ËÆ∞ÂΩï" << std::endl;
        }
        
        return records;
    }

    // Â§öÁ∫øÁ®ãÂ∑•‰ΩúÂáΩÊï∞
    void workerThread(std::queue<ImportTask>& task_queue, std::mutex& queue_mutex, 
                     ThreadSafeStats& stats, int total_groups,
                     std::chrono::high_resolution_clock::time_point start_time,
                     ProgressBar& progress_bar) {
        
        while (true) {
            ImportTask task(0, 0, {});
            
            // Ëé∑Âèñ‰ªªÂä°
            {
                std::lock_guard<std::mutex> lock(queue_mutex);
                if (task_queue.empty()) {
                    break;
                }
                task = std::move(task_queue.front());
                task_queue.pop();
            }
            
            // ÊâßË°å‰ªªÂä°
            processImportTask(task, stats);
            
            // Êõ¥Êñ∞ËøõÂ∫¶
            stats.incrementGroup();
            int processed = stats.getProcessedGroups();
            
            // ÂÆûÊó∂ÊòæÁ§∫ËøõÂ∫¶Êù°ÔºàÊØè10‰∏™‰ªªÂä°Êõ¥Êñ∞‰∏ÄÊ¨°ÔºåÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÔºâ
            if (processed % 10 == 0 || processed == total_groups) {
                auto current_time = std::chrono::high_resolution_clock::now();
                auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(current_time - start_time);
                double rate = stats.getSuccess() / (elapsed.count() > 0 ? elapsed.count() : 1);
                
                progress_bar.displayProgress(processed, total_groups, 
                                           stats.getSuccess(), stats.getError(), 
                                           rate, elapsed.count());
            }
        }
    }

    // Â§ÑÁêÜÂçï‰∏™ÂØºÂÖ•‰ªªÂä°
    void processImportTask(const ImportTask& task, ThreadSafeStats& stats) {
        TAOS* task_conn = conn_pool->getConnection();
        
        try {
            // ÂàõÂª∫Â≠êË°®
            std::string table_name_full = table_name + "_" + std::to_string(task.healpix_id) + "_" + std::to_string(task.source_id);
            std::string create_sql = "CREATE TABLE IF NOT EXISTS " + table_name_full + 
                                   " USING " + table_name + " TAGS (" + std::to_string(task.healpix_id) + 
                                   ", " + std::to_string(task.source_id) + ")";
            
            TAOS_RES* result = taos_query(task_conn, create_sql.c_str());
            if (taos_errno(result) != 0) {
                taos_free_result(result);
                conn_pool->returnConnection(task_conn);
                stats.addError(task.records.size());
                return;
            }
            taos_free_result(result);
            
            // ÊâπÈáèÊèíÂÖ•Êï∞ÊçÆ
            for (size_t i = 0; i < task.records.size(); i += batch_size) {
                size_t end_idx = std::min(i + batch_size, task.records.size());
                
                std::ostringstream insert_sql;
                insert_sql << "INSERT INTO " << table_name_full << " VALUES ";
                
                for (size_t j = i; j < end_idx; ++j) {
                    if (j > i) insert_sql << ",";
                    const auto& record = *task.records[j];
                    insert_sql << "('" << record.timestamp << "'," 
                              << std::fixed << std::setprecision(6) << record.ra << ","
                              << std::fixed << std::setprecision(6) << record.dec << ","
                              << std::fixed << std::setprecision(2) << record.mag << ","
                              << std::fixed << std::setprecision(6) << record.jd_tcb << ")";
                }
                
                result = taos_query(task_conn, insert_sql.str().c_str());
                if (taos_errno(result) == 0) {
                    stats.addSuccess(end_idx - i);
                } else {
                    stats.addError(end_idx - i);
                }
                taos_free_result(result);
            }
            
        } catch (...) {
            stats.addError(task.records.size());
        }
        
        conn_pool->returnConnection(task_conn);
    }
    
    bool importData(const std::vector<AstronomicalRecord>& records) {
        std::cout << "\nüöÄ ÂºÄÂßãÂ§öÁ∫øÁ®ãÂØºÂÖ•Êï∞ÊçÆÂà∞Ë∂ÖÁ∫ßË°®..." << std::endl;
        std::cout << "üßµ Á∫øÁ®ãÊï∞: " << thread_count << std::endl;
        
        auto start_time = std::chrono::high_resolution_clock::now();
        
        // Êåâ (healpix_id, source_id) ÂàÜÁªÑ
        std::map<std::pair<long, int>, std::vector<const AstronomicalRecord*>> groups;
        
        for (const auto& record : records) {
            groups[{record.healpix_id, record.source_id}].push_back(&record);
        }
        
        std::cout << "üìä ÂØºÂÖ•ÁªüËÆ°È¢ÑËßà:" << std::endl;
        std::cout << "   - ÊÄªËÆ∞ÂΩïÊï∞: " << records.size() << std::endl;
        std::cout << "   - Â≠êË°®Êï∞Èáè: " << groups.size() << std::endl;
        std::cout << "   - ÊâπÂ§ÑÁêÜÂ§ßÂ∞è: " << batch_size << std::endl;
        
        // ÂàõÂª∫‰ªªÂä°ÈòüÂàóÂíåËøõÂ∫¶Êù°
        std::queue<ImportTask> task_queue;
        std::mutex queue_mutex;
        ThreadSafeStats stats;
        ProgressBar progress_bar(60);  // 60Â≠óÁ¨¶ÂÆΩÁöÑËøõÂ∫¶Êù°
        
        for (const auto& group : groups) {
            task_queue.emplace(group.first.first, group.first.second, group.second);
        }
        
        std::cout << "\nüìä ÂºÄÂßãÂ§öÁ∫øÁ®ãÂØºÂÖ•..." << std::endl;
        
        // ÂêØÂä®Â∑•‰ΩúÁ∫øÁ®ã
        std::vector<std::thread> workers;
        for (int i = 0; i < thread_count; ++i) {
            workers.emplace_back(&TDengineHealpixImporter::workerThread, this,
                               std::ref(task_queue), std::ref(queue_mutex),
                               std::ref(stats), static_cast<int>(groups.size()), 
                               start_time, std::ref(progress_bar));
        }
        
        // Á≠âÂæÖÊâÄÊúâÁ∫øÁ®ãÂÆåÊàê
        for (auto& worker : workers) {
            worker.join();
        }
        
        // Á°Æ‰øùËøõÂ∫¶Êù°ÊòæÁ§∫100%
        auto final_time = std::chrono::high_resolution_clock::now();
        auto final_elapsed = std::chrono::duration_cast<std::chrono::seconds>(final_time - start_time);
        double final_rate = stats.getSuccess() / (final_elapsed.count() > 0 ? final_elapsed.count() : 1);
        progress_bar.displayProgress(groups.size(), groups.size(), 
                                   stats.getSuccess(), stats.getError(), 
                                   final_rate, final_elapsed.count());
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time);
        
        // ÁîüÊàêÂØºÂÖ•Êä•Âëä
        generateImportReport(records.size(), stats.getSuccess(), stats.getError(), 
                           duration.count(), groups.size());
        
        std::cout << "\nüéâ Â§öÁ∫øÁ®ãÂØºÂÖ•ÂÆåÊàêÔºÅ" << std::endl;
        std::cout << "‚úÖ ÊàêÂäüÂØºÂÖ•: " << stats.getSuccess() << " Êù°" << std::endl;
        std::cout << "‚ùå Â§±Ë¥•: " << stats.getError() << " Êù°" << std::endl;
        std::cout << "üìä ÊàêÂäüÁéá: " << std::fixed << std::setprecision(2) 
                 << (stats.getSuccess() * 100.0 / (stats.getSuccess() + stats.getError())) << "%" << std::endl;
        std::cout << "‚è±Ô∏è ÊÄªËÄóÊó∂: " << duration.count() << " Áßí" << std::endl;
        std::cout << "üöÄ Âπ≥ÂùáÈÄüÂ∫¶: " << (stats.getSuccess() / std::max(1, static_cast<int>(duration.count()))) << " Ë°å/Áßí" << std::endl;
        std::cout << "üìÅ Â≠êË°®Êï∞Èáè: " << groups.size() << std::endl;
        std::cout << "üßµ ‰ΩøÁî®Á∫øÁ®ãÊï∞: " << thread_count << std::endl;
        
        return stats.getSuccess() > 0;
    }
    
private:
    void generateImportReport(int total_records, int success_count, int error_count, 
                            int duration_seconds, int table_count) {
        std::filesystem::create_directories("output/logs");
        
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream timestamp_ss;
        timestamp_ss << std::put_time(std::localtime(&time_t), "%Y%m%d_%H%M%S");
        
        std::string report_file = "output/logs/import_report_" + timestamp_ss.str() + ".txt";
        std::ofstream report(report_file);
        
        if (report.is_open()) {
            report << "================================================================================\n";
            report << "üåü TDengine HealPix Â§öÁ∫øÁ®ãÊï∞ÊçÆÂØºÂÖ•Êä•Âëä (C++ ÁâàÊú¨)\n";
            report << "================================================================================\n";
            
            std::stringstream current_time_ss;
            current_time_ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
            
            report << "ÂØºÂÖ•Êó∂Èó¥: " << current_time_ss.str() << "\n";
            report << "ÁõÆÊ†áÊï∞ÊçÆÂ∫ì: " << db_name << "\n";
            report << "Âü∫Á°ÄNSIDE: " << nside_base << "\n";
            report << "ÁªÜÂàÜNSIDE: " << nside_fine << "\n";
            report << "ÁªÜÂàÜÈòàÂÄº: " << count_threshold << "\n";
            report << "ÊâπÂ§ÑÁêÜÂ§ßÂ∞è: " << batch_size << "\n";
            report << "Á∫øÁ®ãÊï∞: " << thread_count << "\n\n";
            
            report << "üìä ÂØºÂÖ•ÁªüËÆ°:\n";
            report << "  - ÊÄªËÆ∞ÂΩïÊï∞: " << total_records << "\n";
            report << "  - ÊàêÂäüÂØºÂÖ•: " << success_count << "\n";
            report << "  - Â§±Ë¥•ËÆ∞ÂΩï: " << error_count << "\n";
            double success_rate = (success_count * 100.0) / (success_count + error_count);
            report << "  - ÊàêÂäüÁéá: " << std::fixed << std::setprecision(2) << success_rate << "%\n";
            report << "  - ÊÄªËÄóÊó∂: " << duration_seconds << " Áßí\n";
            if (duration_seconds > 0) {
                report << "  - ÂØºÂÖ•ÈÄüÂ∫¶: " << (success_count / duration_seconds) << " Ë°å/Áßí\n";
            }
            
            report << "\nüèóÔ∏è Ë°®ÁªìÊûÑÁªüËÆ°:\n";
            report << "  - Â≠êË°®Êï∞Èáè: " << table_count << "\n";
            
            report << "\nüßµ Âπ∂ÂèëÁªüËÆ°:\n";
            report << "  - ‰ΩøÁî®Á∫øÁ®ãÊï∞: " << thread_count << "\n";
            report << "  - ËøûÊé•Ê±†Â§ßÂ∞è: " << conn_pool->size() << "\n";
            
            report.close();
            std::cout << "üìÑ ÂØºÂÖ•Êä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: " << report_file << std::endl;
        }
    }
};

void printUsage(const char* program_name) {
    std::cout << "Áî®Ê≥ï: " << program_name << " [ÈÄâÈ°π]\n\n";
    std::cout << "ÈÄâÈ°π:\n";
    std::cout << "  --input <Êñá‰ª∂>            ËæìÂÖ•CSVÊñá‰ª∂Ë∑ØÂæÑ\n";
    std::cout << "  --db <Êï∞ÊçÆÂ∫ìÂêç>           TDengineÊï∞ÊçÆÂ∫ìÂêç\n";
    std::cout << "  --nside_base <ÂÄº>         Âü∫Á°ÄhealpixÂàÜËæ®Áéá (ÈªòËÆ§: 64)\n";
    std::cout << "  --nside_fine <ÂÄº>         ÁªÜÂàÜhealpixÂàÜËæ®Áéá (ÈªòËÆ§: 256)\n";
    std::cout << "  --count_threshold <ÂÄº>    ÁªÜÂàÜÈòàÂÄº (ÈªòËÆ§: 10000)\n";
    std::cout << "  --batch_size <ÂÄº>         ÊâπÂ§ÑÁêÜÂ§ßÂ∞è (ÈªòËÆ§: 500)\n";
    std::cout << "  --threads <ÂÄº>            Á∫øÁ®ãÊï∞ (ÈªòËÆ§: 8)\n";
    std::cout << "  --host <‰∏ªÊú∫>             TDengine‰∏ªÊú∫ (ÈªòËÆ§: localhost)\n";
    std::cout << "  --user <Áî®Êà∑>             Áî®Êà∑Âêç (ÈªòËÆ§: root)\n";
    std::cout << "  --password <ÂØÜÁ†Å>         ÂØÜÁ†Å (ÈªòËÆ§: taosdata)\n";
    std::cout << "  --port <Á´ØÂè£>             Á´ØÂè£ (ÈªòËÆ§: 6030)\n";
    std::cout << "  --drop_db                 ÂØºÂÖ•ÂâçÂà†Èô§Êï∞ÊçÆÂ∫ì\n";
    std::cout << "  --help                    ÊòæÁ§∫Ê≠§Â∏ÆÂä©‰ø°ÊÅØ\n\n";
    std::cout << "Á§∫‰æã:\n";
    std::cout << "  " << program_name << " --input data.csv --db sensor_db_healpix --threads 16\n";
    std::cout << "  " << program_name << " --input data.csv --db test_db --nside_base 128 --drop_db --threads 4\n";
}

int main(int argc, char* argv[]) {
    std::string input_file;
    std::string db_name;
    std::string host = "localhost";
    std::string user = "root";
    std::string password = "taosdata";
    int port = 6030;
    int nside_base = 64;
    int nside_fine = 256;
    int count_threshold = 10000;
    int batch_size = 500;
    int thread_count = 8;
    bool drop_db = false;
    
    // Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
    for (int i = 1; i < argc; ++i) {
        if (std::strcmp(argv[i], "--input") == 0 && i + 1 < argc) {
            input_file = argv[++i];
        } else if (std::strcmp(argv[i], "--db") == 0 && i + 1 < argc) {
            db_name = argv[++i];
        } else if (std::strcmp(argv[i], "--host") == 0 && i + 1 < argc) {
            host = argv[++i];
        } else if (std::strcmp(argv[i], "--user") == 0 && i + 1 < argc) {
            user = argv[++i];
        } else if (std::strcmp(argv[i], "--password") == 0 && i + 1 < argc) {
            password = argv[++i];
        } else if (std::strcmp(argv[i], "--port") == 0 && i + 1 < argc) {
            port = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--nside_base") == 0 && i + 1 < argc) {
            nside_base = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--nside_fine") == 0 && i + 1 < argc) {
            nside_fine = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--count_threshold") == 0 && i + 1 < argc) {
            count_threshold = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--batch_size") == 0 && i + 1 < argc) {
            batch_size = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--threads") == 0 && i + 1 < argc) {
            thread_count = std::atoi(argv[++i]);
        } else if (std::strcmp(argv[i], "--drop_db") == 0) {
            drop_db = true;
        } else if (std::strcmp(argv[i], "--help") == 0) {
            printUsage(argv[0]);
            return 0;
        } else {
            std::cerr << "Êú™Áü•ÂèÇÊï∞: " << argv[i] << std::endl;
            printUsage(argv[0]);
            return 1;
        }
    }
    
    // Ê£ÄÊü•ÂøÖÈúÄÂèÇÊï∞
    if (input_file.empty() || db_name.empty()) {
        std::cerr << "‚ùå Áº∫Â∞ëÂøÖÈúÄÂèÇÊï∞ --input Âíå --db" << std::endl;
        printUsage(argv[0]);
        return 1;
    }
    
    // Ê£ÄÊü•ËæìÂÖ•Êñá‰ª∂
    if (!std::filesystem::exists(input_file)) {
        std::cerr << "‚ùå ËæìÂÖ•Êñá‰ª∂‰∏çÂ≠òÂú®: " << input_file << std::endl;
        return 1;
    }
    
    // È™åËØÅÁ∫øÁ®ãÊï∞
    if (thread_count < 1 || thread_count > 64) {
        std::cerr << "‚ùå Á∫øÁ®ãÊï∞ÂøÖÈ°ªÂú® 1-64 ‰πãÈó¥" << std::endl;
        return 1;
    }
    
    try {
        std::cout << "üåü TDengine Healpix Á©∫Èó¥ÂàÜÊûêÂ§öÁ∫øÁ®ãÊï∞ÊçÆÂØºÂÖ•Âô® (C++ ÁâàÊú¨)" << std::endl;
        std::cout << "============================================================" << std::endl;
        
        double file_size_mb = std::filesystem::file_size(input_file) / (1024.0 * 1024.0);
        std::cout << "üìÅ ËæìÂÖ•Êñá‰ª∂: " << input_file << " (" << std::fixed 
                 << std::setprecision(1) << file_size_mb << " MB)" << std::endl;
        std::cout << "üéØ ÁõÆÊ†áÊï∞ÊçÆÂ∫ì: " << db_name << std::endl;
        std::cout << "üè† TDengine‰∏ªÊú∫: " << host << ":" << port << std::endl;
        std::cout << "üßµ Á∫øÁ®ãÊï∞: " << thread_count << std::endl;
        
        TDengineHealpixImporter importer(db_name, host, user, password, port,
                                        nside_base, nside_fine, count_threshold, 
                                        batch_size, thread_count);
        
        // Âà†Èô§Êï∞ÊçÆÂ∫ìÔºàÂ¶ÇÊûúÊåáÂÆöÔºâ
        if (drop_db) {
            if (!importer.dropDatabase()) {
                std::cerr << "‚ùå Âà†Èô§Êï∞ÊçÆÂ∫ìÂ§±Ë¥•ÔºåÂÅúÊ≠¢ÊâßË°å" << std::endl;
                return 1;
            }
        }
        
        // ÂàõÂª∫Ë∂ÖÁ∫ßË°®
        if (!importer.createSuperTable()) {
            std::cerr << "‚ùå ÂàõÂª∫Ë∂ÖÁ∫ßË°®Â§±Ë¥•ÔºåÂÅúÊ≠¢ÊâßË°å" << std::endl;
            return 1;
        }
        
        // Âä†ËΩΩÂíåÂ§ÑÁêÜÊï∞ÊçÆ
        auto records = importer.loadAndProcessData(input_file);
        
        // Â§öÁ∫øÁ®ãÂØºÂÖ•Êï∞ÊçÆ
        bool success = importer.importData(records);
        
        if (success) {
            std::cout << "\nüéä Â§öÁ∫øÁ®ãÊï∞ÊçÆÂØºÂÖ•ÊàêÂäüÂÆåÊàêÔºÅ" << std::endl;
            std::cout << "üí° ‰∏ã‰∏ÄÊ≠•ÔºöËøêË°åÊü•ËØ¢ÊµãËØïÊù•È™åËØÅÊÄßËÉΩ" << std::endl;
            return 0;
        } else {
            std::cout << "\nüí• Êï∞ÊçÆÂØºÂÖ•Â§±Ë¥•ÔºÅ" << std::endl;
            return 1;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "‚ùå ÈîôËØØ: " << e.what() << std::endl;
        return 1;
    }
} 